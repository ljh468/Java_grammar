package Object_grammer08;

/*******************************************************************
 * 쓰레드의 구현
 * 1. Thread클래스를 상속
 * 2. Runnable인터페이스를 구현
 *******************************************************************/
class ThreadEx1_1 extends Thread{
    // 쓰레드가 수행할 작업을 작성
    public void run(){
        for(int i = 0; i < 500; i++){
//            System.out.println(this.getName()); // 조상인 Thread의 getName()을 호출
            System.out.print(0);
        }
    }
}
class ThreadEx1_2 implements Runnable{
    // 쓰레드가 수행할 작업을 작성
    @Override
    public void run() {
        for (int i = 0; i < 500; i++) {
            // Thread.currentThread() - 현재 실행중인 Thread를 반환
//            System.out.println(Thread.currentThread().getName());
            System.out.print(1);
        }
    }
}
public class ch13_01_프로세스와쓰레드 {
    /*******************************************************************
     * process & thread
     * 프로세스 : 실행 중인 프로그램, 자원(resource)과 쓰레드로 구성
     * 쓰레드 : 프로세스 내에서 실제 작업을 수행. 모든 프로세스는 최소한 하나의 쓰레드를 가지고 있다.
     * (프로세스 : 쓰레드 = 공장 : 일꾼)
     * "하나의 새로운 프로세스를 생성하는 것 보다
     * 하나의 새로운 쓰레드를 생성하는 것이 더 적은 비용이 든다." (효율적)
     *******************************************************************/
    /*******************************************************************
     * 멀티쓰레드의 장,단점
     * 대부분의 프로그램이 멀티쓰레드로 작성되어 있다.
     * 장점 : 시스템 자원을 보다 효율적으로 사용할 수 있다.
     *       사용자에 대한 응답성이 향상된다. (한 번에 한 가지일만 가능)
     *       작업이 분리되어 코드가 간결해 진다.
     * 단점 : 동기화(synchronization)에 주의해야 한다. (공유로 인한 고려할 사항이 많음)
     *       교착상태(deadd-lock)가 발생하지 않도록 주의해야 한다.
     *       각 쓰레드가 효율적으로 고르게 실행될 수 있게 해야한다.
     *******************************************************************/
    public static void main(String[] args) {
        // Thread 클래스를 상속받은 객체를 사용
        ThreadEx1_1 t1 = new ThreadEx1_1();

        // Runnable인터페이스를 구현한 객체를 사용
        Thread t2 = new Thread(new ThreadEx1_2());

        /*******************************************************************
         * 쓰레드의 실행
         * 쓰레드를 생성한 후에 start()를 호출해야 쓰레드가 작업을 시작한다.
         * OS스케쥴러가 실행순서를 결정 (순서를 정할 수 없음)
         * 
         * start()메서드는 스택을 새로 생성하고 스택에 run()메서드를 올리고 종료됨
         * (서로 독립적으로 작업 수행)
         *******************************************************************/
        t1.start();
        t2.start();
    }
}
